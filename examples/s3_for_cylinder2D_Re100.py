"""
    Execute the sparse spatial sampling algorithm on 2D CFD data, export the resulting mesh and fields as XDMF and HDF5
    files.

    The test case here is an OpenFoam tutorial with some adjustments to the number of cells and Reynolds number,
    currently:

        - cylinder2D (at Re = 100), located under: $FOAM_TUTORIALS/incompressible/pimpleFoam/laminar/
          or in the flow_data repository under: https://github.com/AndreWeiner/flow_data

    IMPORTANT: the size of the data matrix (from the original CFD data) provided for interpolation onto the generated
               coarser grid must be

                - [N_cells, N_dimensions, N_snapshots] (vector field)
                - [N_cells, 1, N_snapshots] (scalar field)

                to correctly execute the 'export()' method of the Datawriter class. If the data was created with,
                OpenFoam s_cube.utils.export_openfoam_fields can be used alternatively to automatically export a given
                number of fields.

    In this example, the cylinder is represented by a center and radius (no STL file).
"""
import logging
import torch as pt

from os.path import join

from sparseSpatialSampling.export import ExportData
from sparseSpatialSampling.geometry import CubeGeometry, SphereGeometry
from sparseSpatialSampling.sparse_spatial_sampling import SparseSpatialSampling
from sparseSpatialSampling.utils import load_foam_data, export_openfoam_fields, write_svd_s_cube_to_file


if __name__ == "__main__":
    # load paths to the CFD data
    load_path = join("..", "data", "2D", "cylinder2D_re1000")
    save_path = join("..", "run", "final_benchmarks", "cylinder2D", "results")

    # how much of the metric within the original grid should be captured at least
    min_metric = 0.75
    save_name = "metric_{:.2f}".format(min_metric)

    # boundaries of the masked domain for the cylinder
    bounds = [[0, 0], [2.2, 0.41]]  # [[xmin, ymin], [xmax, ymax]]
    cylinder = [[0.2, 0.2], 0.05]  # [[x, y], r]

    # load the CFD data
    field, coord, _, write_times = load_foam_data(load_path, bounds)

    # create geometry objects for the domain and the cylinder
    domain = CubeGeometry("domain", True, bounds[0], bounds[1])
    geometry = SphereGeometry("cylinder", False, cylinder[0], cylinder[1], refine=True)

    # create a S^3 instance
    s_cube = SparseSpatialSampling(coord, pt.std(field, 1), [domain, geometry], save_path, save_name,
                                   "cylinder2D", min_metric=min_metric, write_times=write_times, n_jobs=6)

    # execute S^3
    s_cube.execute_grid_generation()

    # create export instance, export all fields into the same HFD5 file and create single XDMF from it
    export = ExportData(s_cube, write_new_file_for_each_field=False)

    # we used the time steps t = 0.4 ... t_end for computing the metric, but we want to export all time steps, so reset
    # the 'times' property
    export.write_times = None

    # export the fields available in all time steps
    export_openfoam_fields(export, load_path, bounds)

    # alternatively, we can export data available at only certain time steps as
    # export.write_times = [str(i.item()) for i in pt.arange(0.1, 0.5, 0.1)]          # replace with actual time steps
    # export.export(coord, field.unsqueeze(1), "p", _n_snapshots_total=None)

    # compute SVD on grid generated by S^3 and export the results to HDF5 & XDMF
    write_svd_s_cube_to_file(["p", "U"], save_path, save_name, export.new_file, 50, rank=int(1e5))
