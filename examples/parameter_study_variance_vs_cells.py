"""
    execute parameter study for different target metrics of the generated grid wrt the original grid from CFD for
    various test cases
"""
import torch as pt
from os.path import join

from sparseSpatialSampling.export import ExportData
from sparseSpatialSampling.geometry import CubeGeometry, SphereGeometry
from examples.s3_for_cylinder2D_Re100 import write_svd_s_cube_to_file
from sparseSpatialSampling.sparse_spatial_sampling import SparseSpatialSampling
from sparseSpatialSampling.utils import export_openfoam_fields, load_foam_data


def execute_parameter_study(coordinates: pt.Tensor, metric: pt.Tensor, geometries: list, boundaries: list,
                            save_path: str, load_path: str, grid_name: str,
                            variances_to_run: pt.Tensor = pt.arange(0.25, 1.05, 0.05), fields: list = None) -> None:
    """
    wrapper function for executing the parameter study captured variance of original grid vs. number of cells final
    grid and required execution times of S^3

    :param coordinates: coordinates of the original grid from CFD
    :param metric: the metric based on which the grid is generated
    :param geometries: list containing the domain and geometries
    :param boundaries: boundaries of the domain
    :param save_path: path in which directory the results should be saved to
    :param load_path: path to the original CFD data
    :param grid_name: name of the grid, only used internally in XDMF and HDF5 files
    :param variances_to_run: for which target variances the S^3 should be executed
    :param fields: fields to export, either str or list[str]. If 'None' then all available fields at the first time
                   step will be exported
    :return: None
    """
    for v in variances_to_run:
        save_name = "interpolated_mesh_variance_{:.2f}".format(v.item())
        s_cube = SparseSpatialSampling(coordinates, metric, geometries, save_path, save_name, grid_name,
                                       min_metric=v.item(), n_jobs=6)
        # execute S^3
        s_cube.execute_grid_generation()

        # create export instance, export all fields into the same HFD5 file and create single XDMF from it
        export = ExportData(s_cube, write_new_file_for_each_field=False)

        # export the fields
        export_openfoam_fields(export, load_path, boundaries, fields=fields)

        # compute SVD on grid generated by S^3 and export the results to HDF5 & XDMF
        write_svd_s_cube_to_file(["p", "U"], save_path, save_name, export.new_file, 50, rank=int(1e5))


if __name__ == "__main__":
    # -----------------------------------------   execute for cylinder   -----------------------------------------
    load_path_cylinder = join("..", "data", "2D", "cylinder2D_re1000")
    save_path_cylinder = join("..", "run", "final_benchmarks", "cylinder2D", "no_geometry_refinement_with_dl_constraint")

    # boundaries of the masked domain for the cylinder
    bounds = [[0, 0], [2.2, 0.41]]  # full domain
    cylinder = [[0.2, 0.2], 0.05]  # [[x, y], [r]]

    # load the CFD data
    pressure, coord, _, _ = load_foam_data(load_path_cylinder, bounds)

    # create geometry objects for the domain and the cylinder
    domain = CubeGeometry("domain", True, bounds[0], bounds[1])
    geometry = SphereGeometry("cylinder", False, cylinder[0], cylinder[1], refine=False)

    # execute the parameter study for the cylinder
    execute_parameter_study(coord, pt.std(pressure, 1), [domain, geometry], bounds, save_path_cylinder,
                            load_path_cylinder, "cylinder2D")

    # -----------------------------------------   execute for cube   -----------------------------------------
    load_path_cube = join("..", "data", "3D", "surfaceMountedCube_original_grid_size", "fullCase")
    save_path_cube = join("..", "run", "final_benchmarks", "surfaceMountedCube", "results")

    # boundaries of the masked domain for the cube, [[xmin, ymin, zmin], [xmax, ymax, zmax]]
    bounds = [[0, 0, 0], [9, 14.5, 2]]

    # load the CFD data
    pressure, coord, _, _ = load_foam_data(load_path_cube, bounds, n_dims=3)

    # define the geometry object for the domain and cube
    domain = CubeGeometry("domain", True, bounds[0], bounds[1])
    geometry = CubeGeometry("cube", False, [3.5, 4, -1], [4.5, 5, 1])

    # execute the parameter study for the cylinder
    execute_parameter_study(coord, pt.std(pressure, 1), [domain, geometry], bounds, save_path_cube, load_path_cube,
                            "cube", variances_to_run=pt.arange(0.4, 1.05, 0.05), fields=["p", "U"])
