"""
    Execute the sparse spatial sampling algorithm on 3D CFD data, export the resulting mesh and fields as XDMF and HDF5
    files.

    The test case here is the OpenFoam tutorial

        - surfaceMountedCube, located under: $FOAM_TUTORIALS/incompressible/pimpleFoam/LES/

    IMPORTANT: the size of the data matrix (from the original CFD data) provided for interpolation onto the generated
               coarser grid must be

                - [N_cells, N_dimensions, N_snapshots] (vector field)
                - [N_cells, 1, N_snapshots] (scalar field)

                to correctly execute the 'export()' method of the Datawriter class. If the data was created with,
                OpenFoam s_cube.utils.export_openfoam_fields can be used alternatively to automatically export a given
                number of fields.

    In this example, the cube can be represented by an STL file or by given position and dimensions.
"""
import torch as pt

from os.path import join

from sparseSpatialSampling.export import ExportData
from sparseSpatialSampling.geometry import CubeGeometry, GeometrySTL3D
from sparseSpatialSampling.utils import export_openfoam_fields, load_foam_data
from examples.s3_for_cylinder2D_Re100 import write_svd_s_cube_to_file
from sparseSpatialSampling.sparse_spatial_sampling import SparseSpatialSampling


if __name__ == "__main__":
    # path to original surfaceMountedCube simulation (size ~ 8.4 GB, reconstructed)
    load_path = join("..", "data", "3D", "surfaceMountedCube_original_grid_size", "fullCase")
    save_path = join("..", "run", "parameter_study_variance_as_stopping_criteria", "surfaceMountedCube", "results")

    # how much of the metric within the original grid should be captured at least
    min_metric = 0.5
    save_name = "metric_{:.2f}".format(min_metric)

    # load the CFD data in the given boundaries, [[xmin, ymin, zmin], [xmax, ymax, zmax]]
    bounds = [[0, 0, 0], [15, 9, 2]]
    field, coord, _, write_times = load_foam_data(load_path, bounds, n_dims=3)

    # create a setup for geometry objects for the domain
    domain = CubeGeometry("domain", True, bounds[0], bounds[1])

    # either define the cube by its dimensions...
    geometry = CubeGeometry("cube", False, [3.5, 4, -1], [4.5, 5, 1])

    # ... or use the provided STL file
    # geometry = GeometrySTL3D("cube", False, join("..", "tests", "cube.stl"))

    # execute the S^3 algorithm
    s_cube = SparseSpatialSampling(coord, pt.std(field, 1), [domain, geometry], save_path, save_name, "cube",
                                   min_metric=min_metric, write_times=write_times, n_jobs=6)

    # execute S^3
    s_cube.execute_grid_generation()

    # create export instance, export all fields into the same HFD5 file and create single XDMF from it
    export = ExportData(s_cube, write_new_file_for_each_field=False)

    # export the fields available in all time steps
    export_openfoam_fields(export, load_path, bounds, fields=["U", "p"])

    # alternatively, we can export data available at only certain time steps as
    # export.write_times = [str(i.item()) for i in pt.arange(0.1, 0.5, 0.1)]         # replace with actual time steps
    # export.export(coord, field.unsqueeze(1), "p", _n_snapshots_total=None)

    # compute SVD on grid generated by S^3 and export the results to HDF5 & XDMF
    write_svd_s_cube_to_file(["p", "U"], save_path, save_name, export.new_file, 50, rank=int(1e5))
