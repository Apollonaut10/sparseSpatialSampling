"""
    Load the SVD results of the interpolated field (generated grid with S^3) and compare it to the original field from
    CFD for the cylinder_3D_Re3900 test case
"""
import h5py
import torch as pt
import matplotlib.pyplot as plt

from os.path import join
from os import path, makedirs
from typing import Union, Tuple
from matplotlib.patches import Circle, Rectangle
from sklearn.neighbors import KNeighborsRegressor

from flowtorch.data import FOAMDataloader, mask_box

from post_processing.compare_svd_OAT import plot_psd, plot_singular_values, plot_mode_coefficients


def plot_pod_modes(coord_original, coord_inter, U_orig, U_inter, _s_orig, _s_inter, _save_path: str, _save_name: str,
                   n_mode: int = 4, d: float = 0.1, plane: int = 0) -> None:
    """
    plot the POD modes of the cylinder3D_Re3900 simulation on a 2D-plane;
    currently only x-y- and x-z-planes are supported

    :param coord_original: coordinates of the plane for the original simulation
    :param coord_inter: coordinates of the plane for the grid generated by S^3
    :param U_orig: modes of the SVD for the original simulation
    :param U_inter: modes of the SVD for the data generated by S^3
    :param _s_orig: singular values of the SVD for the original simulation
    :param _s_inter: singular values of the SVD for the data generated by S^3
    :param _save_path: directory to which the plot should be saved to
    :param _save_name: name of the plot
    :param n_mode: number of modes to plot
    :param d: diameter of the cylinder
    :param plane: dimension of the plane, 0 = x-y-plane, 2 = x-z-plane
    :return: None
    """
    # check if the vertices are 2D
    assert coord_original.size(-1) == 2, "The size of the coordinates for the original data must be 2D."
    assert coord_inter.size(-1) == 2, "The size of the coordinates for the data generated by S^3 must be 2D."

    vmax = max(U_orig[:, :n_mode*2].max().item(), U_inter[:, :n_mode*2].max().item())
    vmin = -vmax
    levels = pt.linspace(vmin, vmax, 100)

    # M = 0.27, 0.53, 0.77
    flip = [1, 2, 3]

    if plane == 0:
        fig, ax = plt.subplots(n_mode, 2, sharex="all", sharey="all", figsize=(6, 7))
    elif plane == 2:
        fig, ax = plt.subplots(n_mode, 2, sharex="all", sharey="all", figsize=(6, 4))
    else:
        raise NotImplementedError

    for row, m in enumerate(range(0, n_modes*2, 2)):
        ax[row][0].tricontourf(coord_original[:, 0] / d, coord_original[:, 1] / d, U_orig[:, m], vmin=vmin,
                               vmax=vmax, levels=levels, cmap="seismic", extend="both")
        # flip sign of modes so it is consistent
        if row in flip:
            ax[row][1].tricontourf(coord_inter[:, 0] / d, coord_inter[:, 1] / d, U_inter[:, m] * -1,
                                   vmin=vmin, vmax=vmax, levels=levels, cmap="seismic", extend="both")
        else:
            ax[row][1].tricontourf(coord_inter[:, 0] / d, coord_inter[:, 1] / d, U_inter[:, m], vmin=vmin,
                                   vmax=vmax, levels=levels, cmap="seismic", extend="both")
        if plane == 0:
            ax[row][0].add_patch(Circle((0.8 / d, 1 / d), radius=0.05 / d, color="black"))
            ax[row][1].add_patch(Circle((0.8 / d, 1 / d), radius=0.05 / d, color="black"))
        elif plane == 2:
            ax[row][0].add_patch(Rectangle((0.8 / d, 0), width=1, height=coord_original[:, 1].max() / d,
                                           color="black"))
            ax[row][1].add_patch(Rectangle((0.8 / d, 0), width=1, height=coord_original[:, 1].max() / d,
                                           color="black"))
        ax[row][0].set_aspect("equal")
        ax[row][1].set_aspect("equal")

        if plane == 0:
            ax[row][0].set_xlim(5, coord_original[:, 0].max() / d)
            ax[row][0].set_ylim(5, 15)
        elif plane == 2:
            ax[row][0].set_xlim(7, coord_original[:, 0].max() / d)
            ax[row][0].set_ylim(0, coord_original[:, 1].max() / d)

        # add singular values as title
        for col in range(2):
            if col == 0:
                ax[row][col].set_title(r"$\sigma_{" + str(m + 1) + "} = " + "{:.4f}".format(_s_orig[m]) + "$")
            else:
                ax[row][col].set_title(r"$\sigma_{" + str(m + 1) + "} = " + "{:.4f}".format(_s_inter[m]) + "$")

    # ax[0][0].set_title("$original$")
    # ax[0][1].set_title("$S^3$")
    if plane == 0:
        fig.supylabel("$y / d$")
    elif plane == 2:
        fig.supylabel("$z / d$")
    fig.supxlabel("$x / d$")
    fig.tight_layout()
    fig.subplots_adjust()
    plt.savefig(join(_save_path, f"{_save_name}.png"), dpi=340)
    plt.close("all")


def interpolate_plane(vertices: pt.Tensor, modes: pt.Tensor, direction: int, target: Union[int, float], n_jobs: int = 8,
                      EPS: Union[int, float] = 1e-2) -> Tuple[pt.Tensor, pt.Tensor]:
    """
    interpolate 3D volume data onto a 2D plane at a specified location using a KNN regressor

    :param vertices: cell centers of the 3D grid
    :param modes: POD modes corresponding to the grid with a dimension of [N_cells, N_components, N_modes]
    :param direction: const. direction of the plane, 1 = x-z-plane, 2 = x-y-plane, 0 is not implemented
    :param target: target coordinate of the plane for the direction held const.
    :param n_jobs: number of CPU o used for interpolation
    :param EPS: safety margin to account for non-constant spacing of the cell centers
    :return: vertices and interpolated modes of the plane
    """
    # get the nearest vertices to the target plane
    _coord_idx = pt.argmin((vertices[:, direction] - pt.ones((vertices.size(0),)) * target).abs())

    # create a box around the target plane and mask out all the vertices which exceed this box,
    # then create a new plane at the target coordinate
    if direction == 1:
        _mask = mask_box(vertices, [-100, vertices[_coord_idx, direction] - EPS, -100],
                         [100, vertices[_coord_idx, direction] + EPS, 100])

        _verts = pt.cat([vertices[_mask][:, 0].unsqueeze(-1), target * pt.ones((vertices[_mask].size(0), 1)),
                         vertices[_mask][:, 2].unsqueeze(-1)], dim=-1)

    elif direction == 2:
        _mask = mask_box(vertices, [-100, -100, vertices[_coord_idx, direction] - EPS],
                         [100, 100, vertices[_coord_idx, direction] + EPS])

        _verts = pt.cat([vertices[_mask][:, :direction], target * pt.ones((vertices[_mask].size(0), 1))], dim=-1)
    else:
        raise NotImplementedError

    # get rid of unused points before interpolation
    vertices = vertices[_mask]
    modes = modes[_mask]

    # now use a KNN regressor to interpolate the modes onto the target plane using all data within the mask box
    _modes_inter = []
    _knn = KNeighborsRegressor(n_neighbors=20, weights="distance", n_jobs=n_jobs)
    for m in range(modes.size(-1)):
        _knn.fit(vertices, modes[:, :, m])
        _modes_inter.append(pt.from_numpy(_knn.predict(_verts)).unsqueeze(-1))

    return _verts, pt.cat(_modes_inter, dim=-1)


if __name__ == "__main__":
    # which fields and settings to use
    field_name = "U"
    metric = ["0.25", "0.50", "0.75"]
    diameter = 0.1

    # path to the HDF5 file
    load_path = join("/media", "janis", "Elements", "Janis", "Scube", "cylinder3D_Re3900",
                     "results_with_geometry_refinement_no_dl_constraint", "SVD_500_snapshots")
    file_name = [f"cylinder3D_Re3900_metric_{m}_{field_name}_svd.h5" for m in metric]

    # the actual captured metric may differ from the filename
    legend = [r"$\mathrm{original}$"] + [r"$\mathcal{M}_\mathrm{approx} = " + f"{m}$" for m in ["0.27", "0.53", "0.77"]]

    # path to the directory to which the plots should be saved to
    save_path_results = join("..", "run", "final_benchmarks", "cylinder3D_Re3900_local_TKE",
                             "plots_SVD_paper_final")

    # load the field of the original CFD data
    svd_orig = h5py.File(join("/media", "janis", "Elements", "Janis", "cylinder_3D_Re3900_tests",
                              "results_SVD_original_cylinder3D_Re3900", "original_500_snapshots",
                              f"cylinder3D_Re3900_original_{field_name}_svd.h5"))

    # field from generated grid
    svd_inter = [h5py.File(join(load_path, f)) for f in file_name]

    # load the corresponding write times and vertices from the original simulation since flowtorch doesn't support
    # distributed cases for the FOAM2HDF5 converter as of now
    loader = FOAMDataloader(join("/media", "janis", "Elements", "Janis", "cylinder_3D_Re3900_tests",
                                 "cylinder_3D_Re3900"))
    times = pt.tensor(list(map(float, loader.write_times))[1:501])

    # create directory for plots
    if not path.exists(save_path_results):
        makedirs(save_path_results)

    # plot frequency spectrum
    plot_psd([svd_orig.get("constant/V")[()]]+[sv.get("constant/V")[()] for sv in svd_inter],
             (times[1] - times[0]).item(), len(times), save_path_results,
             f"comparison_psd_metric_{metric[0]}_{metric[-1]}", legend=legend, xlim=(0, 0.35), u_inf=39, chord=diameter,
             n_modes=6)

    # plot singular values
    plot_singular_values([pt.from_numpy(svd_orig.get("constant/s")[()])] +
                         [pt.from_numpy(sv.get("constant/s")[()]) for sv in svd_inter], save_path_results,
                         f"comparison_singular_values_metric_{metric[0]}_{metric[-1]}", legend=legend)

    # plot POD mode coefficients (right singular vectors)
    plot_mode_coefficients(times, [svd_orig.get("constant/V")[()]] +
                           [sv.get("constant/V")[()] for sv in svd_inter], save_path_results,
                           f"comparison_pod_mode_coefficients_metric_{metric[0]}_{metric[-1]}",
                           legend=legend, u_inf=39, chord=diameter, n_modes=6, oat=False)

    # plot a 2D slice of the modes
    n_modes = 4
    component = {0: "x", 1: "y", 2: "z"}

    # define the coordinates of the target planes
    target_z = pt.pi / 2 * diameter
    target_y = 1

    for case in range(len(metric)):
        print(f"Plotting modes in the x-y-plane for metric {metric[case]}.")

        # load the modes once, we want to plot every 2nd mode, so we have to load twice n_modes
        modes_orig_3D = pt.cat([pt.from_numpy(svd_orig.get(f"constant/mode_{i + 1}")[()]).unsqueeze(-1) for i in
                               range(n_modes * 2)], dim=-1)
        modes_inter_3D = pt.cat([pt.from_numpy(svd_inter[case].get(f"constant/mode_{i + 1}")[()]).unsqueeze(-1) for i in
                                range(n_modes * 2)], dim=-1)

        # interpolate the modes onto a plane on the x-y-plane
        vertices_orig, modes_orig = interpolate_plane(loader.vertices, modes_orig_3D, 2, target_z)
        vertices_inter, modes_inter = interpolate_plane(pt.from_numpy(svd_inter[case].get("grid/centers")[()]),
                                                        modes_inter_3D, 2, target_z, EPS=0.1)

        # plot the modes on the x-y-plane, component 0 = Ux, 1 = Uy, 2 = Uz
        for cmp in range(3):
            plot_pod_modes(vertices_orig[:, :2], vertices_inter[:, :2], modes_orig[:, cmp, :].squeeze(),
                           modes_inter[:, cmp, :].squeeze(), svd_orig.get("constant/s")[()],
                           svd_inter[case].get("constant/s")[()], save_path_results,
                           f"comparison_modes_metric_{metric[case]}_U{component[cmp]}_x_y_plane", n_mode=n_modes)

        print(f"Plotting modes in the x-z-plane for metric {metric[case]}.")

        # interpolate the modes onto a plane on the x-z-plane
        vertices_orig, modes_orig = interpolate_plane(loader.vertices, modes_orig_3D, 1, target_y, EPS=0.05)
        vertices_inter, modes_inter = interpolate_plane(pt.from_numpy(svd_inter[case].get("grid/centers")[()]),
                                                        modes_inter_3D, 1, target_y, EPS=0.05)

        # plot the modes on the x-z-plane
        for cmp in range(3):
            plot_pod_modes(vertices_orig[:, [0, 2]], vertices_inter[:, [0, 2]], modes_orig[:, cmp, :].squeeze(),
                           modes_inter[:, cmp, :].squeeze(), svd_orig.get("constant/s")[()],
                           svd_inter[case].get("constant/s")[()], save_path_results,
                           f"comparison_modes_metric_{metric[case]}_U{component[cmp]}_x_z_plane", n_mode=n_modes,
                           plane=2)
